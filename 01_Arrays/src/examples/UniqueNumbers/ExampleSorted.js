function findUniqueSorted(phoneNumbers) {
  const uniqueNumbers = [];
  
  // Возьмем самый первый элемент
  let prevNumber = phoneNumbers[0];

  // И начнем двигаться по массиву начиная со второго элемента
  for (let i = 1; i < phoneNumbers.length; ++i) {
      // Как только текущий элемент не равен предыдущему —
      
      // Бинго! Предыдущий элемент уже можно записывать как уникальный
      if (phoneNumbers[i] !== prevNumber) {
          uniqueNumbers.push(prevNumber);
          prevNumber = phoneNumbers[i];
      }
  }

  // В конце у нас останется последний элемент массива,
  // нужно не забыть его тоже положить в массив уникальных элементов
  uniqueNumbers.push(prevNumber);
  return uniqueNumbers;
}


function main() {
  const phoneNumbers = [
    +79000000000, +79000000000,
    +79000000001,
    +79000000002, +79000000002,
    +79000000003, +79000000003, +79000000003, +79000000003,
    +79000000004
  ];

  const uniqueNumbers = findUniqueSorted(phoneNumbers);
  console.log(`Unique numbers: ${uniqueNumbers.join(',')}`);
}

main();

module.exports = {
  findUniqueSorted
}

/*
  ————————————————————————
  —— Подумать на досуге ——
  ————————————————————————

  Заметьте, что нам нужно последовательно сравнивать пары элементов массива.
  Нулевой с первым, первый со вторым, второй с третьим и т.д.
  Это классическая подзадача, которая постоянно встречается в разных алгоритмах,
  и решать ее можно по-разному.

  Один из способов это итерация не по всему массиву,
  а например начиная с индекса 1 (как в этом примере),
  или наоборот итерация не до конца а только до предпоследнего элемента.


  Также можно итерироваться с начала и до конца,
  но предусмотреть специальные условия в теле цикла для первого или последнего элемента.
  (Упражнение на разминку мелкой кодерской моторики)

  Попробуйте переписать алгоритм с использованием циклов:

  (1)  for(let i = 0; i < phoneNumbers.length - 1; i++)
  (2)  for(let i = 0; i < phoneNumbers.length; i++)

*/